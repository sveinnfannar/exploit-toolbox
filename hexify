#!/usr/bin/python2
"""A small tool to 'compile' exploits to shellcode to shellcode

Example usage:
echo "e8 de ad be ef    # call deadbeef
'90' * 28               # create 28 NOPS
rev('ca fe ba be')      # reverse the bytes for little endian machines
asm('''                 # inline arbitrary assembly (note triple ''')
    push $0x08048c93
    ret
''')
" > exploit.in
./hexify exploit.in > exploit.out

Author: Helgi Kristvin
"""

import time
import tempfile
import os
import binascii
import sys
import re


def elf_read_code(name):
    length = filter(lambda n: n.find('.text') > -1,
            os.popen('objdump --section .text -h %s' % name).read().splitlines())

    length = ''.join(length).split()
    length, offset = int(length[2], 16), int(length[5], 16)

    return open(name).read()[offset:length + offset]

def asm(code):
    name = tempfile.mktemp()
    with open(name + ".S", 'w') as f:
        f.write(code)
    f.close()
    os.popen('gcc -o %s.o -m32 -c %s.S' % (name, name))

    try:
        d = elf_read_code(name + ".o")
    finally:
        for i in [name + ".S", name + ".o"]:
            try:
                os.unlink(i)
            except:
                pass

    return ' '.join(map(lambda n: n.encode('hex'), list(d)))

def ascii(s):
    return ' '.join(map(lambda n: n.encode('hex'), s))

def rev(s):
    return ' '.join(s.split(' ')[::-1])

def balanced(s):
    c = 0
    for i in s:
        if i == '(':
            c += 1
        elif i == ')':
            c -= 1

    return c == 0

def parse_data(data):
    out = ""
    comment = re.compile(r"#.*$")
    l = None # read lines until parens are balanced
    for line in data.splitlines():
        if l == None:
            l = ""
        l += '\n' + re.sub(comment, "", line)

        if balanced(l):
            try:
                out += str(eval(l))
            except Exception, e:
                if l.find('asm') > -1:
                    print >> sys.stderr, "Could not compile assembly, \"", l, "\""
                    raise e
                out += l
            l = None
    if l:
        print >> sys.stderr, "WARNING: Unbalanced parens found in %s, output might be wrong" % sys.argv[1]
    return filter(lambda n: n.strip() != "", out)

def build(fname, *args, **kwargs):
    ascii = kwargs['ascii']
    out_name = kwargs['out']

    data = open(fname).read()
    out = parse_data(data)

    try:
        if not ascii:
            out = binascii.a2b_hex(out)
        else:
            out = ''.join(map(lambda n: n.upper(), out))

        if not out_name:
            print out
        else:
            open(out_name, 'w').write(out)

    except Exception, e:
        sys.stderr.write("Could not convert to hex. Length found was %s. string '%s'\n" % (len(out), out))

def watch(fname, f, *args, **kwargs):
    last = None
    while True:
        now = os.stat(fname).st_mtime
        if now != last:
            last = now
            try:
                f(fname, *args, **kwargs)
            except:
                pass

        time.sleep(0.1)

if __name__ == "__main__":
    from optparse import OptionParser

    parser = OptionParser()
    parser.add_option("-a", "--ascii", action="store_true", dest="ascii", default=False)
    parser.add_option("-o", "--out",   action="store", dest="out", default=None,
            help="Print the output binary to a file instead of stdout")
    parser.add_option("-w", "--watch", action="store_true", dest="watch", default=False,
            help="If watch is on it'll continually run and rebuild the file on change")

    parser.set_usage("[options] <file>")

    (options, args) = parser.parse_args()

    if not args:
        parser.print_help()
        sys.exit(1)

    if options.watch:
        watch(args[0], build, **options.__dict__)
    else:
        build(args[0], **options.__dict__)
