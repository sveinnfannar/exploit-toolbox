#!/usr/bin/python2
"""A small tool to 'compile' exploits to shellcode to shellcode

Example usage:
echo "e8 de ad be ef    # call deadbeef
'90' * 28               # create 28 NOPS
rev('ca fe ba be')      # reverse the bytes for little endian machines
asm('''                 # inline arbitrary assembly (note triple ''')
    push $0x08048c93
    ret
''')
" > exploit.in
./hexify exploit.in > exploit.out

Author: Helgi Kristvin
"""

import tempfile
import os
import binascii
import sys
import re

def elf_read_code(name):
    length = filter(lambda n: n.find('.text') > -1,
            os.popen('objdump --section .text -h %s' % name).read().splitlines())

    length = ''.join(length).split()
    length, offset = int(length[2], 16), int(length[5], 16)

    return open(name).read()[offset:length + offset]

def asm(code):
    name = tempfile.mktemp()
    with open(name + ".S", 'w') as f:
        f.write(code)
    f.close()
    os.popen('gcc -o %s.o -m32 -c %s.S' % (name, name))

    d = elf_read_code(name + ".o")

    os.unlink(name + ".S")
    os.unlink(name + ".o")

    return ' '.join(map(lambda n: n.encode('hex'), list(d)))

def rev(s):
    return ' '.join(s.split(' ')[::-1])

def balanced(s):
    c = 0
    for i in s:
        if i == '(':
            c += 1
        elif i == ')':
            c -= 1

    return c == 0

def parse_data(data):
    out = ""
    comment = re.compile(r"#.*$")
    l = None # read lines until parens are balanced
    for line in data.splitlines():
        if l == None:
            l = ""
        l += '\n' + re.sub(comment, "", line)

        if balanced(l):
            try:
                out += str(eval(l))
            except Exception, e:
                if l.find('asm') > -1:
                    print >> sys.stderr, "Could not compile assembly, \"", l, "\""
                    exit(0)
                out += l
            l = None
    if l:
        print >> sys.stderr, "WARNING: Unbalanced parens found in %s, output might be wrong" % sys.argv[1]
    return filter(lambda n: n.strip() != "", out)


if __name__ == "__main__":
    ascii = False
    if sys.argv[1].strip() == "-":
        data = sys.stdin.read()
    elif sys.argv[1].strip() == "--ascii":
        ascii = True
        data = open(sys.argv[2]).read()
    else:
        data = open(sys.argv[1]).read()
    
    out = parse_data(data)
    try:
        if not ascii:
            out = binascii.a2b_hex(out)
        sys.stdout.write(out)
    except:
        sys.stderr.write("Could not convert to hex. Length found was %s. string '%s'\n" % (len(out), out))
